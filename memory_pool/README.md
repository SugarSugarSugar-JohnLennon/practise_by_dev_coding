# 内存池学习笔记

本项目是我学习C++内存池（二级分配器）实现的记录，目标是理解高效内存分配的原理、实现方式和实际应用。

## 📚 学习目标

1. 理解内存池的设计思想和适用场景
2. 掌握固定块内存池的实现方法
3. 学习线程安全的分配与释放机制
4. 了解STL allocator背后的思想
5. 通过示例和压力测试加深理解

## 🏗️ 目录结构

```
memory_pool/
├── memory_pool.h         # 内存池模板类头文件
├── memory_pool.inl       # 内存池模板实现
├── simple_example.cpp    # 简单用法示例
├── stress_test.cpp       # 多线程压力测试
├── CMakeLists.txt        # CMake构建配置
├── build.sh              # 构建脚本
└── README.md             # 学习笔记
```

## ✨ 内存池设计要点

- **固定块大小**：适合频繁分配/释放小对象，避免内存碎片
- **空闲链表**：O(1)分配和释放，效率极高
- **线程安全**：加锁保护空闲链表，支持多线程并发
- **简单易用**：接口类似于malloc/free

## 🚀 使用方法

### 1. 构建项目
```bash
chmod +x build.sh
./build.sh
```

### 2. 简单示例
```cpp
struct MyStruct { int a; double b; char msg[16]; };
MemoryPool<sizeof(MyStruct)> pool(10);
void* p = pool.allocate();
MyStruct* obj = new(p) MyStruct{1, 2.0, "hi"};
pool.deallocate(p);
```

### 3. 多线程压力测试
- 见 stress_test.cpp，支持8线程高并发分配/释放

## 🧠 学习要点

### 为什么需要内存池？
- 系统malloc/free开销大，频繁分配小对象易碎片化
- 内存池预先分配大块内存，按需切分，回收快
- STL的std::vector、std::list等底层都可用自定义allocator

### 二级分配器思想
- STL allocator分两级：大对象直接malloc，小对象用内存池
- 本项目实现类似二级分配器的小对象池

### 线程安全实现
- 用std::mutex保护空闲链表
- 分配/释放都加锁，保证多线程安全

### 典型应用场景
- 容器节点分配（如list/map）
- 网络包、消息对象池
- 游戏对象池、内存管理优化

## 🔍 常见问题
- **内存泄漏**：分配后未释放，或释放后重复释放
- **线程安全**：多线程下必须加锁
- **块大小选择**：太小浪费空间，太大浪费内存

## 📈 性能测试
- 单线程分配/释放百万次，耗时远低于malloc/free
- 多线程压力下，分配/释放速度稳定

## 🎯 总结
通过本项目，我深入理解了内存池的实现原理、线程安全机制和实际应用场景，为后续学习高性能C++编程打下了基础。

## 📚 参考资料
- 《STL源码剖析》侯捷
- C++标准库文档
- 各种开源内存池实现 