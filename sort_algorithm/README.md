# 排序算法
---
## 冒泡排序
冒泡排序通过**重复交换相邻的逆序对**，逐渐把最大的数“冒泡”到末尾。
* 每一轮，从头开始比较相邻的两个元素：

  * 如果前者比后者大，就交换；
  * 否则不动。
* 每轮会把“当前未排序部分中最大的元素”放到最后。
* 重复 `n-1` 轮，直到所有元素有序。

为了优化，可以加一个标志位 `swapped`，如果某一轮没有发生交换，说明数组已经有序，可以提前结束。
```cpp
void bubble_sort(vector<int>& vec) {
    int len = vec.size();
    bool swapped;

    for(int i = 0; i < len; ++i) {
        swapped = false;
        for(int j = 0; j < len - (i + 1); ++j) {
            if(vec[j] > vec[j + 1]) {
                swap(vec[j], vec[j + 1]);
                swapped = true;
            }
        }
        if(!swapped) break;
    }
}
```
| 情况     | 时间复杂度 | 空间复杂度 | 是否稳定 | 说明                       |
| ---------- | ------------ | ------------ | ---------- | ---------------------------- |
| 最好情况 | O(n)       | O(1)       | ✅ 是    | 数组已经有序，只需一轮判断 |
| 平均情况 | O(n²)     | O(1)       | ✅ 是    | 所有元素随机               |
| 最坏情况 | O(n²)     | O(1)       | ✅ 是    | 数组完全逆序               |
- 稳定性说明：不会交换相等元素的位置，所以是**稳定排序**。
- 空间复杂度：**原地排序**，没有额外的数组或栈。

适用场景与数据:
- **适合小数据量**（几百个以内）
- **适合数据几乎有序的情况**
- **不适合大数据量场景**
- **教学与理解排序原理非常适合**
---
## 选择排序
选择排序通过**每轮选择最小值**（或最大值），将其放到正确的位置。

具体逻辑：

- 从数组第 `i` 个元素开始（`i = 0 ~ n-2`）：

  - 在剩余 `n-i` 个元素中找出**最小值**的下标 `minIndex`
  - 将 `arr[i]` 与 `arr[minIndex]` 交换
- 经过 `n-1` 次选择，整个数组有序

每次都“选出一个最小的”，放在前面，所以叫“选择排序”。

```cpp
void select_sort(vector<int>& vec) {
    int len = vec.size();
    for(int i = 0; i < len; ++i) {
        int minIndex = i;
        for(int j = i + 1; j < len; ++j) {
            if(vec[j] < vec[minIndex]) minIndex = j;
        }
        if(i != minIndex) {
            swap(vec[i], vec[minIndex]);
        }
    }
}
```
| 情况     | 时间复杂度 | 空间复杂度 | 是否稳定 | 说明                      |
| ---------- | ------------ | ------------ | ---------- | --------------------------- |
| 最好情况 | O(n²)     | O(1)       | ❌ 否    | 即使有序也需要 n² 次比较 |
| 平均情况 | O(n²)     | O(1)       | ❌ 否    | 每次都要找最小值          |
| 最坏情况 | O(n²)     | O(1)       | ❌ 否    | 无法保证相同元素顺序      |
- **不稳定**：相等元素有可能被后面的最小值跳过并交换
- **原地排序**，不需要额外空间

适用场景与数据:
- **适合数据量小、交换操作代价大** 的场景（它**比较多，但交换少**）
- **适合教学用途**，逻辑直观清晰
- **不适合大数据量或对稳定性有要求的情况**
---

## 插入排序
插入排序的思想类似打扑克牌时整理手牌的方式：
- 初始时认为第一个元素已经“有序”
- 从第 2 个元素开始，依次将当前元素“插入”到前面已经排好序的部分中，使得插入后仍然有序

操作过程：
1. 设当前要插入的数为 `key`，从 `arr[1]` 到 `arr[n-1]`
2. 从 `i-1` 开始向前比较，如果 `arr[j] > key`，则将 `arr[j]` 向后移一位
3. 重复直到找到比 `key` 小或相等的位置，将 `key` 插入到那个位置

```cpp
void insert_sort(vector<int>& vec) {
    int len = vec.size();

    for(int i = 1; i < len; ++i) { // 从第二个元素开始，前面设定为有序
        int key = vec[i]; // 当前需要排序的元素
        int j = i - 1; // 从这里开始往前扫，找到位置，过程中后移
        while(j >= 0 && vec[j] > key) { // 找到第一个比key小的，插在他后面。
            vec[j + 1] = vec[j]; // 后移让位置
            --j;
        }
        vec[j + 1] = key;
    }
}
```

| 情况 | 时间复杂度 | 空间复杂度 | 是否稳定 | 说明 |
| ------ | ------------ | ------------ | ---------- | ------ |

| 最好情况 | O(n) | O(1) | ✅ 是 | 数组本身有序 |
| ---------- | ------ | ------ | ------- | -------------- |

| 平均情况 | O(n²) | O(1) | ✅ 是 | 插入到中间位置 |
| ---------- | -------- | ------ | ------- | ---------------- |

| 最坏情况 | O(n²) | O(1) | ✅ 是 | 数组完全逆序 |
| ---------- | -------- | ------ | ------- | -------------- |

- **稳定排序**：不会打乱相同元素的相对顺序
- **原地排序**，空间复杂度 O(1)

适用场景与数据:
- **非常适合数据量小的数组**
- **特别适合**：**几乎有序的数组**
- 对于**链表结构**，插入排序效率更高（插入操作无需移动）

---

## 快速排序
快速排序基于**分治法**，核心思想是：

- **选一个基准值（pivot）** ，一般是第一个、最后一个、中间值或随机选；
- **分区**：把数组中比基准小的放到左边，比基准大的放到右边；
- **递归地排序左边和右边的子数组**。

流程举例：
- 数组：[5, 2, 9, 1, 5, 6]
- 选 pivot\=5
- 分成两部分：

  - 左边：[2, 1]
  - 右边：[9, 5, 6]
- 分别对左右递归排序，再拼接

```cpp
int parition(vector<int>& vec, int low, int high) {
    int pivot = vec[high]; // 基准值
    int i = low - 1;       // 小于基准的

    for(int j = low; j < high; ++j) {
        if(vec[j] <= pivot){
            ++i;
            swap(vec[i], vec[j]);
        }
    }

    swap(vec[i + 1], vec[high]);
    return i + 1;
}

void quick_sort_helper(vector<int>& vec, int low, int high) {
    if (low < high) {
        int pi = parition(vec, low, high); // 分区
        quick_sort_helper(vec, low, pi - 1);      // 排左半边
        quick_sort_helper(vec, pi + 1, high);     // 排右半边
    }
}

void quick_sort(vector<int>& vec) {
     quick_sort_helper(vec, 0, vec.size() - 1);
}
```

| 情况     | 时间复杂度 | 空间复杂度（递归栈） | 是否稳定 | 说明                           |
| ---------- | ------------ | ---------------------- | ---------- | -------------------------------- |
| 最好情况 | O(n log n) | O(log n)             | ❌       | 每次刚好对半分                 |
| 平均情况 | O(n log n) | O(log n)             | ❌       | 分布均匀时                     |
| 最坏情况 | O(n²)     | O(n)                 | ❌       | 每次分出一个元素，如已排序数组 |

- 快排不是稳定排序：**相等元素可能交换顺序**
- 是 **原地排序**，空间复杂度仅为递归栈开销

适用场景与数据:
- **最常用的排序算法之一**
- 实际中比 O(n²) 的冒泡、选择、插入排序快很多
- 适用于大多数通用场景（可随机选 pivot 来避免最坏情况）

## 归并排序

## 堆排序

## 计数排序