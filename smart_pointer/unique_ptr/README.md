# MyUniquePtr 实现学习笔记

本项目旨在从零开始实现一个类似 C++ 标准库中的 `std::unique_ptr` 的智能指针。通过这个过程，可以加深对 C++ **RAII (Resource Acquisition Is Initialization)** 思想、**独占所有权 (Exclusive Ownership)** 模型以及**移动语义 (Move Semantics)** 的理解。

## 核心概念: 独占所有权

`MyUniquePtr` 的核心思想非常纯粹：在任何时刻，只有一个指针能够管理（并最终负责释放）一个给定的动态分配对象。它保证了资源的生命周期与 `MyUniquePtr` 对象的生命周期严格绑定，杜绝了忘记 `delete` 导致的内存泄漏。

- **独占性**: 一个资源（如动态分配的内存）只能被一个 `MyUniquePtr` 拥有。
- **禁止拷贝**: 为了维护独占性，`MyUniquePtr` 是**不可拷贝**的。你不能像普通指针一样，简单地将它赋给另一个 `MyUniquePtr`，因为这会产生两个指针指向同一块内存，违反了"独占"原则，可能导致二次释放等严重问题。
- **所有权转移**: 如果需要转移资源的所有权，必须显式地进行。这是通过 C++11 引入的**移动语义** (`std::move`) 来实现的。当一个 `MyUniquePtr` 被"移动"到另一个 `MyUniquePtr` 时，原始的指针会放弃所有权（内部指针被设为 `nullptr`），新的指针接管资源。这是一种高效且安全的资源交接方式。

## 实现要点

1.  **构造与析构**:
    -   构造函数接收一个裸指针，并获得其所有权。通常将其声明为 `explicit`，以防止不安全的隐式类型转换。
    -   析构函数负责检查其内部是否持有一个有效的指针，如果是，则 `delete` 它。

2.  **禁用拷贝**:
    -   通过将拷贝构造函数和拷贝赋值运算符声明为 `= delete`，从语法层面彻底禁止了拷贝行为。任何尝试拷贝 `MyUniquePtr` 的代码都将导致编译错误。

3.  **启用移动**:
    -   实现移动构造函数和移动赋值运算符。这两个函数接收一个右值引用 (`MyUniquePtr&&`)。在函数体内部，它们会"窃取"源指针的内部裸指针，并将源指针的内部裸指针置空，从而完成所有权的转移。

4.  **核心 API**:
    -   `operator*` 和 `operator->`: 提供类似原始指针的解引用操作。
    -   `get()`: 返回内部的裸指针，但不放弃所有权。
    -   `release()`: **放弃**所有权，并返回内部的裸指针。调用者此后必须手动管理该指针的生命周期。`MyUniquePtr` 自身则变为空指针。
    -   `reset(p)`: 释放当前拥有的指针（如果有），并接管新的指针 `p` 的所有权。

## 文件结构

- `unique_ptr.h`: `MyUniquePtr` 的完整实现。
- `main.cpp`: 测试用例，演示了 `MyUniquePtr` 的创建、所有权转移和核心 API 的使用。
- `CMakeLists.txt` 和 `build.sh`: 用于编译和运行项目。

## 如何编译和运行

```bash
# 切换到 unique_ptr 目录
cd smart_pointer/unique_ptr

# 赋予执行权限
chmod +x build.sh

# 执行脚本
./build.sh
```

脚本会自动编译代码，并在 `bin` 目录下生成可执行文件 `u_ptr_demo` 并运行它。 